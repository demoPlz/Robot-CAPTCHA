<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Data Collection Monitor</title>
    <script type="importmap">
    {
      "imports": {
        "three":              "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
        "three/addons/":      "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/",
        "urdf-loader":        "https://cdn.jsdelivr.net/npm/urdf-loader@0.12.6/src/URDFLoader.js?module"
      }
    }
    </script>
    <style>
        * { margin:0; padding:0; box-sizing:border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background:#f8fafc; height:100vh; overflow:hidden;
        }
        .container { display:flex; flex-direction:column; height:100vh; gap:20px; padding:20px; }
        .top-section { display:flex; gap:20px; }
        .camera-section { flex:3; background:white; border-radius:12px; box-shadow:0 4px 20px rgba(0,0,0,0.08); padding:20px; }
        .status-control-column { flex:1; display:flex; flex-direction:column; gap:20px; }
        .status-section, .control-section {
            background:white; border-radius:12px; box-shadow:0 4px 20px rgba(0,0,0,0.08); padding:15px; display:flex; flex-direction:column; gap:15px;
        }
        .main-content { display:flex; flex:1; gap:20px; min-height:0; }
        .left-panel, .right-panel {
            background:white; border-radius:12px; box-shadow:0 4px 20px rgba(0,0,0,0.08); padding:20px; display:flex; flex-direction:column;
        }
        .left-panel { flex:1; }
        .panel-header { border-bottom:2px solid #e2e8f0; padding-bottom:16px; margin-bottom:20px; display:flex; align-items:center; justify-content:space-between; gap:12px; }
        .panel-header h2 { color:#1e293b; font-size:24px; font-weight:600; }
        .camera-views {
            width:100%; display:grid; grid-template-columns:repeat(3,1fr); grid-template-rows:repeat(2,1fr);
            gap:12px; height:400px;
        }
        .camera-view {
            background:#f1f5f9; border-radius:4px; border:1px solid #e2e8f0; display:flex; align-items:center; justify-content:center; overflow:hidden; transition:all .2s ease;
            position:relative;
        }
        .camera-view:hover { border-color:#3b82f6; box-shadow:0 2px 8px rgba(59,130,246,.15); }
        .camera-image { width:100%; height:100%; object-fit:contain; border-radius:3px; }
        .camera-layer { position:absolute; inset:0; width:100%; height:100%; object-fit:contain; border-radius:3px; display:none; }
        .camera-layer.is-visible { display:block; }
        .camera-placeholder { color:#64748b; font-size:10px; text-align:center; padding:8px; }
        .status-card { background:#f8fafc; border:1px solid #e2e8f0; border-radius:8px; padding:16px; }
        .status-card h3 { color:#1e293b; font-size:16px; font-weight:600; margin-bottom:12px; }
        .status-item { display:flex; justify-content:space-between; align-items:center; padding:8px 0; border-bottom:1px solid #e2e8f0; }
        .status-item:last-child { border-bottom:none; }
        .status-label { color:#64748b; font-size:14px; }
        .status-value { color:#1e293b; font-weight:500; font-size:14px; }
        .status-indicator { width:12px; height:12px; border-radius:50%; display:inline-block; margin-right:8px; }
        .status-indicator.connected { background:#10b981; box-shadow:0 0 8px rgba(16,185,129,.4); }
        .status-indicator.disconnected { background:#ef4444; box-shadow:0 0 8px rgba(239,68,68,.4); }
        .status-indicator.warning { background:#f59e0b; box-shadow:0 0 8px rgba(245,158,11,.4); }
        .progress-bar { width:100%; height:8px; background:#e2e8f0; border-radius:4px; overflow:hidden; }
        .progress-fill { height:100%; background:linear-gradient(90deg,#3b82f6,#1d4ed8); border-radius:4px; transition:width .3s ease; }
        .robot-state { padding:12px; border-radius:6px; font-weight:500; text-align:center; margin:8px 0; }
        .robot-state.stationary { background:#d1fae5; color:#065f46; border:1px solid #6ee7b7; }
        .robot-state.resetting { background:#fef3c7; color:#92400e; border:1px solid #fcd34d; animation:pulse 2s infinite; }
        @keyframes pulse { 0%,100%{opacity:1;} 50%{opacity:.7;} }
        .error-message { background:#fef2f2; border:1px solid #fecaca; color:#dc2626; padding:12px; border-radius:6px; font-size:14px; text-align:center; }
        .control-buttons { display:flex; flex-direction:column; gap:12px; }
        .control-button {
            display:flex; align-items:center; justify-content:center; gap:8px; padding:12px 16px; border:none; border-radius:10px; font-size:14px; font-weight:600;
            cursor:pointer; transition:all .2s ease; box-shadow:0 2px 8px rgba(0,0,0,.1);
        }
        .control-button:hover { transform:translateY(-2px); box-shadow:0 4px 16px rgba(0,0,0,.15); }
        .control-button:active { transform:translateY(0); box-shadow:0 2px 8px rgba(0,0,0,.1); }
        .control-button:disabled { opacity:.6; cursor:not-allowed; transform:none; }
        .control-button.loading { opacity:.7; cursor:wait; }
        .fast-forward-btn { background:linear-gradient(135deg,#3b82f6,#1d4ed8); color:white; }
        .fast-forward-btn:hover { background:linear-gradient(135deg,#2563eb,#1e40af); }
        .rerecord-btn { background:linear-gradient(135deg,#f59e0b,#d97706); color:white; }
        .rerecord-btn:hover { background:linear-gradient(135deg,#e3a008,#c2701a); }
        .stop-btn { background:linear-gradient(135deg,#ef4444,#dc2626); color:white; }
        .stop-btn:hover { background:linear-gradient(135deg,#dc2626,#b91c1c); }
        .control-icon { font-size:20px; }

        /* Episode charts */
        .episode-charts-container { max-height:calc(100vh - 200px); overflow-y:auto; padding-right:8px; }
        .episode-chart { background:#f8fafc; border:1px solid #e2e8f0; border-radius:8px; padding:16px; margin-bottom:16px; transition:all .2s ease; }
        .episode-chart:hover { border-color:#3b82f6; box-shadow:0 2px 8px rgba(59,130,246,.15); }
        .episode-chart.current { border-color:#10b981; background:#f0fdf4; box-shadow:0 2px 8px rgba(16,185,129,.15); }
        .episode-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:12px; }
        .episode-title { font-weight:600; font-size:14px; color:#1e293b; }
        .episode-stats { font-size:12px; color:#64748b; }
        .chart-container { position:relative; height:80px; background:white; border-radius:4px; border:1px solid #e2e8f0; overflow:hidden; }
        .chart-y-axis { position:absolute; left:0; top:10px; bottom:16px; width:32px; display:flex; flex-direction:column; justify-content:space-between; padding:0 4px; background:rgba(248,250,252,.9); border-right:1px solid #e2e8f0; }
        .y-axis-label { font-size:10px; color:#64748b; text-align:center; }
        .chart-bars { position:absolute; top:10px; left:32px; right:8px; height:calc(100% - 26px); display:flex; align-items:end; padding:0 8px 16px 8px; gap:1px; overflow-x:auto; overflow-y:hidden; scrollbar-width:thin; }
        .chart-bars::-webkit-scrollbar { height:4px; }
        .chart-bars::-webkit-scrollbar-track { background:#f1f5f9; border-radius:2px; }
        .chart-bars::-webkit-scrollbar-thumb { background:#cbd5e1; border-radius:2px; }
        .chart-bars::-webkit-scrollbar-thumb:hover { background:#94a3b8; }
        .state-bar-container { flex:none; width:3px; height:100%; display:flex; flex-direction:column; justify-content:end; position:relative; min-width:2px; max-width:20px; }
        .state-bar-container.clickable { cursor:pointer; }
        .state-bar { background:linear-gradient(180deg,#e2e8f0,#cbd5e1); border-radius:2px 2px 0 0; transition:height .3s ease, box-shadow .15s ease, transform .1s ease; position:relative; min-height:2px; width:100%; }
        .state-bar.empty { background:#e2e8f0; height:100% !important; }
        .state-bar.critical-complete { background:linear-gradient(180deg,#dc2626,#991b1b) !important; }
        .state-bar.critical-incomplete { background:linear-gradient(180deg,#f87171,#dc2626) !important; }
        .state-bar.critical-awaiting-vlm { background:linear-gradient(180deg,#f9a8d4,#f472b6) !important; box-shadow:inset 0 0 0 1px rgba(219,39,119,.25); }
        .state-bar.regular-complete { background:linear-gradient(180deg,#2563eb,#1d4ed8) !important; }
        .state-bar.regular-incomplete { background:linear-gradient(180deg,#60a5fa,#2563eb) !important; }
        .state-bar-label { position:absolute; bottom:-16px; left:50%; transform:translateX(-50%); font-size:10px; color:#64748b; white-space:nowrap; }
        .chart-x-axis { position:absolute; bottom:0; left:32px; right:8px; height:16px; display:flex; align-items:center; padding:0 8px; background:rgba(248,250,252,.9); border-top:1px solid #e2e8f0; font-size:10px; color:#64748b; }

        /* === VLM Details Modal === */
        .modal-overlay {
            position:fixed; inset:0; background:rgba(2,6,23,0.55); display:none; align-items:center; justify-content:center; z-index:9999;
        }
        .modal-overlay.show { display:flex; }
        .modal-card {
            width:min(1100px, 95vw);
            height:min(85vh, 860px);
            background:white;
            border-radius:14px;
            box-shadow:0 30px 80px rgba(2,6,23,0.35);
            display:grid;
            grid-template-columns: 60% 40%;
            grid-template-rows: auto 1fr auto;
            overflow:hidden;
        }
        .modal-header {
            grid-column:1 / -1;
            display:flex; align-items:center; justify-content:space-between;
            padding:14px 16px; border-bottom:1px solid #e2e8f0; background:#f8fafc;
        }
        .modal-title { font-size:16px; font-weight:600; color:#0f172a; }
        .modal-close-btn { background:transparent; border:none; font-size:20px; cursor:pointer; color:#64748b; }
        .modal-main { display:contents; }
        .modal-left { padding:16px; border-right:1px solid #e2e8f0; display:flex; align-items:center; justify-content:center; background:#0b1220; }
        .modal-maincam { max-width:100%; max-height:100%; object-fit:contain; border-radius:8px; }
        .modal-right { padding:16px; display:flex; flex-direction:column; gap:12px; }
        .field-label { font-size:12px; color:#475569; font-weight:600; }
        .select-wrap { display:flex; gap:8px; align-items:center; }
        .select-el { width:100%; padding:10px 12px; border:1px solid #cbd5e1; border-radius:10px; background:#fff; font-size:14px; color:#0f172a; }
        .prompt-box { flex:1; background:#f8fafc; border:1px solid #e2e8f0; border-radius:10px; padding:12px; overflow:auto; white-space:pre-wrap; font-size:14px; color:#0f172a; }
        .kv-line { font-size:12px; color:#334155; }
        .modal-footer { grid-column:1 / -1; display:flex; justify-content:flex-end; gap:10px; padding:12px 16px; border-top:1px solid #e2e8f0; background:#f8fafc; }
        .btn { padding:10px 14px; border:none; border-radius:10px; font-weight:600; cursor:pointer; transition:transform .1s ease, box-shadow .2s ease; }
        .btn:active { transform:translateY(0.5px); }
        .btn-primary { background:#2563eb; color:white; }
        .btn-primary:hover { box-shadow:0 6px 18px rgba(37,99,235,.25); }
        .btn-secondary { background:#e2e8f0; color:#0f172a; }
        .btn-danger { background:#dc2626; color:white; }
        .muted { color:#64748b; }

        /* Toasts */
        .toast {
            position:fixed; bottom:18px; right:18px; background:#0f172a; color:white; padding:10px 12px; border-radius:10px; box-shadow:0 8px 24px rgba(2,6,23,.25);
            font-size:13px; z-index:10000; opacity:0; transform:translateY(8px); transition:opacity .2s ease, transform .2s ease;
        }
        .toast.show { opacity:1; transform:translateY(0); }

        /* === NEW: Segmented toggle for Critical-only === */
        .segmented {
            display:inline-flex; border:1px solid #cbd5e1; border-radius:12px; overflow:hidden; background:#f8fafc;
        }
        .segmented button {
            padding:8px 12px; font-weight:600; font-size:13px; border:none; background:transparent; color:#334155; cursor:pointer;
            transition:background .15s ease, color .15s ease;
        }
        .segmented button + button { border-left:1px solid #e2e8f0; }
        .segmented button.active { background:#2563eb; color:white; }

        /* === NEW: Critical-only chart adjustments === */
        .chart-bars.critical-only .state-bar-container.is-regular { display:none; }
        .chart-bars.critical-only .state-bar-container.is-critical {
            width:12px; min-width:12px; max-width:28px;
        }
        .chart-bars.critical-only .state-bar-container.clickable .state-bar {
            box-shadow:0 0 0 2px rgba(37,99,235,.35) inset;
        }
        .state-bar-container.clickable .state-bar {
            box-shadow:0 0 0 1px rgba(37,99,235,.25) inset;
        }
        .state-bar-container.clickable:hover .state-bar {
            transform:translateY(-1px);
        }
        /* Clicked marker */
        .state-bar-container.clicked .state-bar {
            box-shadow:0 0 0 2px rgba(16,185,129,.9) inset, 0 0 8px rgba(16,185,129,.3) !important;
        }

        /* === NEW: Hover preview popover === */
        .preview-popover {
            position:fixed; z-index:10000; pointer-events:none; background:#0b1220; border:1px solid #334155; border-radius:10px; box-shadow:0 16px 40px rgba(2,6,23,.35);
            padding:6px; display:flex; align-items:center; justify-content:center; min-width:160px; min-height:90px;
        }
        .preview-popover img { max-width:280px; max-height:180px; display:block; border-radius:6px; }
        .preview-popover .loading { font-size:12px; color:#cbd5e1; padding:18px 12px; }
        .preview-popover .badge {
            display:none; /* Hide text badge - only show obs view */
        }
        /* Sticky header improvement for the toolbar */
        .states-header { position:sticky; top:0; background:white; z-index:5; }

        /* === Manual entry UI === */
        .input, .textarea {
            width:100%;
            padding:10px 12px;
            border:1px solid #cbd5e1;
            border-radius:10px;
            font-size:14px;
            color:#0f172a;
            background:#fff;
        }
        .textarea { min-height:110px; resize:vertical; }
        .segmented.small button { font-size:12px; padding:6px 10px; }

        /* Optional: chip if you later show a "Locked (manual)" pill */
        .lock-chip {
            display:inline-flex; align-items:center; gap:6px;
            background:#ecfccb; color:#3f6212; border:1px solid #bef264;
            border-radius:999px; padding:4px 8px; font-size:12px; font-weight:600;
        }

        /* Keep the bar clickable even if awaiting VLM */
        .state-bar-container.is-critical .state-bar.critical-awaiting-vlm {
            cursor:pointer;
            box-shadow:0 0 0 2px rgba(37,99,235,.35) inset;
        }

        /* When modal is open, stop keyboard toggle from firing */
        body.modal-open { overflow: hidden; }

        /* === Modal Navigation Bar === */
        .modal-nav-bar {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            flex: 1; /* Take up remaining space in header */
        }
        .modal-nav-squares {
            display: flex;
            gap: 4px;
            align-items: center;
        }
        .modal-nav-square {
            width: 12px;
            height: 12px;
            border: 1px solid #cbd5e1;
            border-radius: 2px;
            background: #e2e8f0;
            cursor: pointer;
            transition: all 0.15s ease;
            position: relative;
        }
        .modal-nav-square:hover {
            background: #cbd5e1;
            border-color: #94a3b8;
        }
        .modal-nav-square.current {
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.8);
            border-color: #1d4ed8;
        }
        .modal-nav-square.visited {
            background: #10b981;
            border-color: #059669;
        }
        .modal-nav-square.unlabeled {
            background: #ef4444 !important;
            border-color: #dc2626 !important;
        }
        .modal-nav-square.checking-label-status {
            background: #f59e0b;
            border-color: #d97706;
            animation: pulse 1s infinite;
        }
        .modal-nav-info {
            font-size: 12px;
            color: #64748b;
            margin-left: 12px;
        }

        /* === Approval Modal === */
        .approval-modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(4px);
        }
        .approval-modal-overlay.show { display: flex; }
        .approval-modal-card {
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 900px;
            width: 90%;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }
        .approval-modal-header {
            padding: 20px 24px;
            border-bottom: 2px solid #e2e8f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .approval-modal-title {
            font-size: 20px;
            font-weight: 700;
            color: #0f172a;
        }
        .approval-modal-body {
            padding: 24px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
        }
        .approval-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .approval-image-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .approval-image-label {
            font-size: 14px;
            font-weight: 600;
            color: #475569;
            text-align: center;
        }
        .approval-image-wrapper {
            background: #0b1220;
            border-radius: 12px;
            padding: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 300px;
        }
        .approval-image {
            max-width: 100%;
            max-height: 400px;
            object-fit: contain;
            border-radius: 8px;
        }
        .approval-modal-footer {
            padding: 16px 24px;
            border-top: 2px solid #e2e8f0;
            display: flex;
            justify-content: center;
            gap: 16px;
            background: #f8fafc;
        }
        .approval-btn {
            padding: 14px 32px;
            border: none;
            border-radius: 12px;
            font-weight: 700;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 140px;
        }
        .approval-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.15);
        }
        .approval-btn:active {
            transform: translateY(0);
        }
        .approval-btn-proceed {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
        }
        .approval-btn-proceed:hover {
            background: linear-gradient(135deg, #059669, #047857);
        }
        .approval-btn-reject {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }
        .approval-btn-reject:hover {
            background: linear-gradient(135deg, #dc2626, #b91c1c);
        }

        /* Pre-Execution Modal Styles */
        .pre-execution-modal-card {
            width: min(95vw, 1600px);
            max-height: 90vh;
            background: white;
            border-radius: 14px;
            box-shadow: 0 30px 80px rgba(2,6,23,0.35);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .pre-execution-modal-body {
            padding: 24px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
            flex: 1;
        }
        .pre-execution-top-row {
            display: flex;
            justify-content: center;
        }
        .pre-execution-top-row .approval-image-container {
            max-width: 600px;
        }
        .pre-execution-views-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
        }
        .pre-exec-view-container {
            position: relative;
            background: #0b1220;
            border-radius: 8px;
            padding: 8px;
            overflow: hidden;
        }
        .pre-exec-view-label {
            position: absolute;
            top: 12px;
            left: 12px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            z-index: 10;
        }
        .pre-exec-view-canvas {
            width: 100%;
            height: auto;
            display: block;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Top Section -->
        <div class="top-section">
            <div class="camera-section">
                <div class="camera-views">
                    <div class="camera-view" id="camera-front"><div class="camera-placeholder">No image</div></div>
                    <div class="camera-view" id="camera-left"><div class="camera-placeholder">No image</div></div>
                    <div class="camera-view" id="camera-right"><div class="camera-placeholder">No image</div></div>
                    <div class="camera-view" id="camera-perspective"><div class="camera-placeholder">No image</div></div>
                    <div class="camera-view" id="camera-obs_main"><div class="camera-placeholder">No image</div></div>
                    <div class="camera-view" id="camera-obs_wrist"><div class="camera-placeholder">No image</div></div>
                </div>
            </div>
            <div class="status-control-column">
                <div class="status-section">
                    <div class="status-card">
                        <div class="status-item">
                            <span class="status-label">Backend Server</span>
                            <span class="status-value" id="server-status">
                                <span class="status-indicator disconnected"></span>
                                Checking...
                            </span>
                        </div>
                    </div>
                    <div class="status-card">
                        <div class="robot-state stationary" id="robot-state">üõë Robot Status Unknown</div>
                    </div>
                </div>
                <div class="control-section">
                    <div class="control-buttons">
                        <button class="control-button fast-forward-btn" id="fast-forward-btn"><span class="control-icon">‚è©</span>Next Episode</button>
                        <button class="control-button rerecord-btn" id="rerecord-btn"><span class="control-icon">üîÑ</span>Re-record Episode</button>
                        <button class="control-button stop-btn" id="stop-btn"><span class="control-icon">‚èπÔ∏è</span>Stop Recording</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <div class="left-panel" style="flex:1;">
                <!-- NEW: header with segmented toggle -->
                <div class="panel-header states-header">
                    <h2>Pending States</h2>
                    <div class="segmented" role="tablist" aria-label="State visibility mode">
                        <button id="toggle-all" role="tab" aria-selected="false">All</button>
                        <button id="toggle-critical" class="active" role="tab" aria-selected="true" title="Keyboard: press I">Critical only</button>
                    </div>
                </div>
                <div class="episode-charts-container" id="episode-charts-container"></div>
            </div>
        </div>
    </div>

    <!-- === VLM DETAILS MODAL === -->
    <div class="modal-overlay" id="vlm-modal">
        <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="vlm-modal-title">
            <div class="modal-header">
                <!-- Navigation bar showing important states - replaces title -->
                <div class="modal-nav-bar" id="modal-nav-bar">
                    <div class="modal-nav-squares" id="modal-nav-squares">
                        <!-- Squares will be populated dynamically -->
                    </div>
                    <div class="modal-nav-info" id="modal-nav-info">
                        State <span id="nav-current-index">1</span> of <span id="nav-total-count">1</span>
                    </div>
                </div>
                <button class="modal-close-btn" id="vlm-modal-close" aria-label="Close">‚úï</button>
            </div>
            <div class="modal-main">
                <div class="modal-left">
                    <img id="modal-maincam" class="modal-maincam" alt="Main camera observation" />
                </div>
                <div class="modal-right">
                    <!-- Source toggle -->
                    <div>
                        <div class="field-label">Source of description:</div>
                        <div class="segmented small" id="vlm-source-toggle">
                            <button id="src-bank" type="button" class="active">Pick from bank</button>
                            <button id="src-manual" type="button">Manual entry</button>
                        </div>
                    </div>

                    <!-- BANK MODE -->
                    <div id="bank-fields">
                        <div class="field-label">Pick description (number = VLM video id):</div>
                        <div class="select-wrap">
                            <select id="modal-description-select" class="select-el"></select>
                        </div>
                        <div style="margin-top:8px;">
                            <div class="field-label">Current text prompt:</div>
                            <div id="modal-prompt-text" class="prompt-box"></div>
                        </div>
                    </div>

                    <!-- MANUAL MODE -->
                    <div id="manual-fields" style="display:none;">
                        <div class="field-label">Manual text prompt:</div>
                        <textarea id="modal-manual-text" class="textarea" placeholder="Type the description you want to save..."></textarea>

                        <div class="field-label" style="margin-top:8px;">Manual video id (optional):</div>
                        <input id="modal-manual-video" class="input" type="number" placeholder="Leave blank if unknown" />
                        <div class="muted" style="margin-top:6px;">Saving in manual mode locks this state against auto-overwrites.</div>
                    </div>

                    <!-- Key/values footer -->
                    <div class="kv-line">
                        <span class="muted">Episode:</span> <span id="kv-episode">-</span>
                        &nbsp;&nbsp;|&nbsp;&nbsp;
                        <span class="muted">State:</span> <span id="kv-state">-</span>
                        &nbsp;&nbsp;|&nbsp;&nbsp;
                        <span class="muted">Video ID:</span> <span id="kv-video">-</span>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" id="vlm-modal-cancel">Close</button>
                <button class="btn btn-primary" id="vlm-modal-save">Save Selection</button>
            </div>
        </div>
    </div>

    <!-- Approval Modal -->
    <div class="approval-modal-overlay" id="approval-modal">
        <div class="approval-modal-card">
            <div class="approval-modal-header">
                <h2 class="approval-modal-title">Approve New Critical State?</h2>
            </div>
            <div class="approval-modal-body">
                <div class="approval-comparison">
                    <div class="approval-image-container">
                        <div class="approval-image-label">Previous Critical State</div>
                        <div class="approval-image-wrapper">
                            <img id="approval-prev-image" class="approval-image" alt="Previous state">
                        </div>
                    </div>
                    <div class="approval-image-container">
                        <div class="approval-image-label">New Critical State</div>
                        <div class="approval-image-wrapper">
                            <img id="approval-new-image" class="approval-image" alt="New state">
                        </div>
                    </div>
                </div>
            </div>
            <div class="approval-modal-footer">
                <div style="display: flex; justify-content: center; gap: 16px; flex: 1;">
                    <button class="approval-btn approval-btn-reject" id="approval-reject-btn">
                        <span class="control-icon">‚ùå</span> Reject & Undo
                    </button>
                    <button class="approval-btn" id="approval-discard-btn" style="background: linear-gradient(135deg, #f97316, #ea580c); color: white;">
                        <span class="control-icon">üóëÔ∏è</span> Discard Jitter States
                    </button>
                    <button class="approval-btn approval-btn-proceed" id="approval-proceed-btn">
                        <span class="control-icon">‚úÖ</span> Proceed
                    </button>
                </div>
                <button class="approval-btn" id="approval-mark-end-btn" style="background: linear-gradient(135deg, #8b5cf6, #6d28d9); font-size: 13px; padding: 10px 20px; min-width: auto;">
                    <span class="control-icon">üèÅ</span> Mark as End
                </button>
            </div>
        </div>
    </div>

    <!-- Undo Classification Modal -->
    <div class="approval-modal-overlay" id="undo-classification-modal">
        <div class="approval-modal-card">
            <div class="approval-modal-header">
                <h2 class="approval-modal-title">Classify Post-Undo State</h2>
                <p style="margin-top: 10px; font-size: 14px; color: #666;">
                    Robot has returned to previous position. Is this a clean undo?
                </p>
            </div>
            <div class="approval-modal-body">
                <div class="approval-comparison">
                    <div class="approval-image-container">
                        <div class="approval-image-label">Target State (Before Undo)</div>
                        <div class="approval-image-wrapper">
                            <img id="undo-previous-image" class="approval-image" alt="Previous state">
                        </div>
                    </div>
                    <div class="approval-image-container">
                        <div class="approval-image-label">Arrived State (After Undo)</div>
                        <div class="approval-image-wrapper">
                            <img id="undo-arrived-image" class="approval-image" alt="Arrived state">
                        </div>
                    </div>
                </div>
                <div id="undo-remaining-actions" style="margin-top: 15px; text-align: center; font-size: 13px; color: #555;"></div>
            </div>
            <div class="approval-modal-footer">
                <div style="display: flex; justify-content: center; gap: 16px; flex: 1;">
                    <button class="approval-btn approval-btn-reject" id="undo-new-state-btn">
                        <span class="control-icon">üÜï</span> New State
                        <div style="font-size: 11px; margin-top: 4px; opacity: 0.8;">Collect new actions</div>
                    </button>
                    <button class="approval-btn approval-btn-proceed" id="undo-old-state-btn">
                        <span class="control-icon">‚ôªÔ∏è</span> Old State
                        <div style="font-size: 11px; margin-top: 4px; opacity: 0.8;">Resample existing actions</div>
                    </button>
                </div>
                <button class="approval-btn" id="undo-mark-end-btn" style="background: linear-gradient(135deg, #8b5cf6, #6d28d9); font-size: 13px; padding: 10px 20px; min-width: auto;">
                    <span class="control-icon">üèÅ</span> Mark as End
                </button>
            </div>
        </div>
    </div>

    <!-- Pre-Execution Approval Modal -->
    <div class="approval-modal-overlay" id="pre-execution-modal">
        <div class="pre-execution-modal-card">
            <div class="approval-modal-header">
                <h2 class="approval-modal-title">Approve Action Before Execution?</h2>
                <p style="margin-top: 10px; font-size: 14px; color: #666;">
                    Review the proposed action with robot visualization before executing
                </p>
            </div>
            <div class="pre-execution-modal-body">
                <!-- Top row: Current observation -->
                <div class="pre-execution-top-row">
                    <div class="approval-image-container">
                        <div class="approval-image-label">Current State (Observation)</div>
                        <div class="approval-image-wrapper">
                            <img id="pre-exec-current-image" class="approval-image" alt="Current state">
                        </div>
                    </div>
                </div>
                <!-- Bottom row: 6 views with robot rendered at goal -->
                <div class="pre-execution-views-grid" id="pre-exec-views-grid">
                    <!-- Views will be dynamically created here -->
                </div>
            </div>
            <div class="approval-modal-footer">
                <div style="display: flex; justify-content: center; gap: 16px; flex: 1;">
                    <button class="approval-btn approval-btn-reject" id="pre-exec-reject-btn">
                        <span class="control-icon">‚ùå</span> Reject & Resample
                    </button>
                    <button class="approval-btn approval-btn-proceed" id="pre-exec-approve-btn">
                        <span class="control-icon">‚úÖ</span> Approve & Execute
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast -->
    <div class="toast" id="app-toast"></div>

    <script>
        // === API bootstrap - use Flask backend directly ===
        async function getCurrentCloudflaredUrl() {
            try {
                // For local development, use localhost backend directly
                if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
                    console.log('[DEV] Using localhost backend');
                    return 'http://127.0.0.1:9000';
                }
                // For production (Netlify), use Cloudflare Tunnel (publicly accessible)
                console.log('[PROD] Using Cloudflare Tunnel backend (publicly accessible)');
                return 'https://crossword-moses-vendor-shipping.trycloudflare.com';
            } catch (error) {
                console.error('Error getting backend URL:', error);
                // Fallback to Cloudflare Tunnel URL
                return 'https://crossword-moses-vendor-shipping.trycloudflare.com';
            }
        }
        let API_BASE_URL = 'https://crossword-moses-vendor-shipping.trycloudflare.com';
        async function initializeApiUrl() {
            if (location.hostname === 'localhost' || location.hostname === '127.0.0.1') {
                if (location.port === '5173' || location.port === '5174') {
                    API_BASE_URL = await getCurrentCloudflaredUrl();
                    console.log('[DEBUG] Monitor using backend URL:', API_BASE_URL);
                } else {
                    API_BASE_URL = 'http://127.0.0.1:9000';
                }
            } else {
                API_BASE_URL = 'https://crossword-moses-vendor-shipping.trycloudflare.com';
                console.log('[DEBUG] Monitor using Tailscale Funnel:', API_BASE_URL);
            }
        }

        // === Perf knobs ===
        const DEBUG = false;
        const CAMERA_POLL_MS = 250;
        const INFO_POLL_MS   = 1000;

        let latestStateInFlight = false;
        let pendingInfoInFlight = false;

        const lastCamUpdate = { front:0, left:0, right:0, perspective:0, obs_main:0, obs_wrist:0 };
        const cameraBuffers = {};
        const camSwapInFlight = {};

        let autoRefreshInterval = null;

        // DOM
        const serverStatus = document.getElementById('server-status');
        const robotState   = document.getElementById('robot-state');

        const fastForwardBtn = document.getElementById('fast-forward-btn');
        const rerecordBtn    = document.getElementById('rerecord-btn');
        const stopBtn        = document.getElementById('stop-btn');

        // Approval modal elements
        const approvalModal = document.getElementById('approval-modal');
        const approvalPrevImage = document.getElementById('approval-prev-image');
        const approvalNewImage = document.getElementById('approval-new-image');
        const approvalProceedBtn = document.getElementById('approval-proceed-btn');
        const approvalRejectBtn = document.getElementById('approval-reject-btn');
        const approvalDiscardBtn = document.getElementById('approval-discard-btn');
        const approvalMarkEndBtn = document.getElementById('approval-mark-end-btn');

        // Undo classification modal elements
        const undoClassificationModal = document.getElementById('undo-classification-modal');
        const undoPreviousImage = document.getElementById('undo-previous-image');
        const undoArrivedImage = document.getElementById('undo-arrived-image');
        const undoRemainingActions = document.getElementById('undo-remaining-actions');
        const undoNewStateBtn = document.getElementById('undo-new-state-btn');
        const undoOldStateBtn = document.getElementById('undo-old-state-btn');
        const undoMarkEndBtn = document.getElementById('undo-mark-end-btn');

        // Pre-execution approval modal elements
        const preExecutionModal = document.getElementById('pre-execution-modal');
        const preExecCurrentImage = document.getElementById('pre-exec-current-image');
        const preExecViewsGrid = document.getElementById('pre-exec-views-grid');
        const preExecApproveBtn = document.getElementById('pre-exec-approve-btn');
        const preExecRejectBtn = document.getElementById('pre-exec-reject-btn');

        const cameraViews = {
            front: document.getElementById('camera-front'),
            left: document.getElementById('camera-left'),
            right: document.getElementById('camera-right'),
            perspective: document.getElementById('camera-perspective'),
            obs_main: document.getElementById('camera-obs_main'),
            obs_wrist: document.getElementById('camera-obs_wrist'),
        };

        const episodeChartsContainer = document.getElementById('episode-charts-container');
        let episodes = [];
        let REQUIRED_RESPONSES_PER_STATE = 1;
        let REQUIRED_RESPONSES_PER_CRITICAL_STATE = 10;

        let userIsScrolling = false;
        let scrollTimeout = null;

        // === Modal State ===
        const vlmModal = document.getElementById('vlm-modal');
        const vlmModalClose = document.getElementById('vlm-modal-close');
        const vlmModalCancel = document.getElementById('vlm-modal-cancel');
        const vlmModalSave = document.getElementById('vlm-modal-save');
        const modalMaincam = document.getElementById('modal-maincam');
        const modalSelect  = document.getElementById('modal-description-select');
        const modalPrompt  = document.getElementById('modal-prompt-text');
        const kvEp         = document.getElementById('kv-episode');
        const kvSt         = document.getElementById('kv-state');
        const kvVid        = document.getElementById('kv-video');
        const appToast     = document.getElementById('app-toast');

        // Navigation elements
        const modalNavSquares = document.getElementById('modal-nav-squares');
        const navCurrentIndex = document.getElementById('nav-current-index');
        const navTotalCount = document.getElementById('nav-total-count');

        // Source toggle + fields
        const srcToggleEl     = document.getElementById('vlm-source-toggle');
        const srcBankBtn      = document.getElementById('src-bank');
        const srcManualBtn    = document.getElementById('src-manual');
        const bankFieldsEl    = document.getElementById('bank-fields');
        const manualFieldsEl  = document.getElementById('manual-fields');
        const manualTextEl    = document.getElementById('modal-manual-text');
        const manualVideoEl   = document.getElementById('modal-manual-video');

        let modalContext = { episodeId:null, stateId:null, selectedVideoId:null, selectedText:null, bank:[] };

        let isManualMode = false;
        function setSourceMode(manual) {
            isManualMode = !!manual;
            srcBankBtn.classList.toggle('active', !manual);
            srcManualBtn.classList.toggle('active', manual);
            bankFieldsEl.style.display   = manual ? 'none' : '';
            manualFieldsEl.style.display = manual ? '' : 'none';
        }
        srcBankBtn.addEventListener('click',  () => setSourceMode(false));
        srcManualBtn.addEventListener('click', () => setSourceMode(true));

        // Keep kv video id in sync in manual mode
        if (manualVideoEl) {
            manualVideoEl.addEventListener('input', () => {
                const v = manualVideoEl.value.trim();
                kvVid.textContent = v === '' ? '-' : v;
            });
        }

        function showToast(msg, timeout=1600) {
            appToast.textContent = msg;
            appToast.classList.add('show');
            setTimeout(() => appToast.classList.remove('show'), timeout);
        }

        // --- Camera plumbing (unchanged) ---
        function ensureCameraBuffers(cameraName) {
            const container = cameraViews[cameraName];
            if (!container) return null;
            let state = cameraBuffers[cameraName];
            if (!state) {
                const img0 = document.createElement('img');
                img0.className = 'camera-image camera-layer';
                const img1 = document.createElement('img');
                img1.className = 'camera-image camera-layer';
                container.appendChild(img0);
                container.appendChild(img1);
                state = cameraBuffers[cameraName] = { imgs:[img0,img1], active:0, lastSrc:'', initialized:false };
            }
            return state;
        }
        async function updateCameraView(name, dataUrl) {
            const container = cameraViews[name];
            if (!container) return;
            if (!dataUrl || !dataUrl.startsWith('data:image/')) {
                const state = cameraBuffers[name];
                if (state) {
                    state.imgs[0].classList.remove('is-visible');
                    state.imgs[1].classList.remove('is-visible');
                    state.initialized = false; state.lastSrc = '';
                }
                if (!container.querySelector('.camera-placeholder')) {
                    const ph = document.createElement('div'); ph.className='camera-placeholder'; ph.textContent='No image';
                    container.appendChild(ph);
                }
                return;
            }
            const now = performance.now();
            if (now - (lastCamUpdate[name]||0) < CAMERA_POLL_MS*0.9) return;
            const state = ensureCameraBuffers(name);
            if (!state) return;
            if (dataUrl === state.lastSrc) return;
            if (camSwapInFlight[name]) return;
            camSwapInFlight[name] = true;
            const backIndex = 1 - state.active;
            const backImg = state.imgs[backIndex];
            try {
                backImg.decoding = 'async';
                backImg.src = dataUrl;
                if (typeof backImg.decode === 'function') {
                    await backImg.decode().catch(()=>{});
                } else {
                    await new Promise(r => backImg.complete ? r() : (backImg.onload = () => r()));
                }
                if (!state.initialized) {
                    const ph = container.querySelector('.camera-placeholder'); if (ph) ph.remove();
                    state.initialized = true;
                }
                state.imgs[state.active].classList.remove('is-visible');
                backImg.classList.add('is-visible');
                state.active = backIndex;
                state.lastSrc = dataUrl;
                lastCamUpdate[name] = now;
            } finally { camSwapInFlight[name] = false; }
        }

        function updateServerStatus(connected) {
            const indicator = serverStatus.querySelector('.status-indicator');
            if (connected) {
                indicator.className = 'status-indicator connected';
                serverStatus.innerHTML = '<span class="status-indicator connected"></span>Connected';
            } else {
                indicator.className = 'status-indicator disconnected';
                serverStatus.innerHTML = '<span class="status-indicator disconnected"></span>Disconnected';
            }
        }
        function updateRobotState(isResetting, resetCountdown) {
            if (isResetting) {
                robotState.className='robot-state resetting';
                const t = resetCountdown>0 ? ` (${Math.ceil(resetCountdown)}s)` : '';
                robotState.textContent = `üîÑ Resetting Environment${t}`;
            } else {
                robotState.className='robot-state stationary';
                robotState.textContent='‚úÖ Ready for Data Collection';
            }
        }
        function updateControlButtons(isResetting) {
            if (isResetting) {
                fastForwardBtn.innerHTML = '<span class="control-icon">‚ñ∂Ô∏è</span>Start Episode';
                fastForwardBtn.title = 'Skip remaining reset time and start episode immediately';
            } else {
                fastForwardBtn.innerHTML = '<span class="control-icon">‚è©</span>Next Episode';
                fastForwardBtn.title = 'Finish current episode and move to next';
            }
        }

        // --- Episode charts ---
        function createEpisodeChartElement(episode) {
            const episodeDiv = document.createElement('div');
            episodeDiv.className = 'episode-chart'; episodeDiv.id = `episode-${episode.id}`;
            if (episode.isCurrentServing) episodeDiv.classList.add('current');
            episodeDiv.innerHTML = `
                <div class="episode-header">
                    <div class="episode-title">Episode ${episode.id}</div>
                    <div class="episode-stats" id="episode-${episode.id}-stats">
                        ${Object.keys(episode.states).length} states, 0 responses
                    </div>
                </div>
                <div class="chart-container">
                    <div class="chart-y-axis">
                        <div class="y-axis-label">${REQUIRED_RESPONSES_PER_CRITICAL_STATE}</div>
                        <div class="y-axis-label">${Math.floor(REQUIRED_RESPONSES_PER_CRITICAL_STATE/2)}</div>
                        <div class="y-axis-label">0</div>
                    </div>
                    <div class="chart-bars" id="episode-${episode.id}-bars"></div>
                    <div class="chart-x-axis">State IDs</div>
                </div>
            `;
            episodeChartsContainer.appendChild(episodeDiv);
            const bars = document.getElementById(`episode-${episode.id}-bars`);
            const stats = document.getElementById(`episode-${episode.id}-stats`);
            episode.barsContainer = bars;
            episode.statsElement = stats;
            episode.barEls = {};
            episode.responsesTotal = 0;
            episode.criticalCount = 0;
            episode.regularCount = 0;

            /* NEW: apply current filter class to new episode containers */
            if (criticalOnlyMode) {
                bars.classList.add('critical-only');
            }
        }

        // === NEW: clicked/visited state tracking ===
        const clickedCriticalStates = new Set(JSON.parse(localStorage.getItem('clickedCriticalStates') || '[]'));
        function stateKey(ep, st) { return `${ep}:${st}`; }
        function markClickedCritical(ep, st) {
            const key = stateKey(ep, st);
            if (!clickedCriticalStates.has(key)) {
                clickedCriticalStates.add(key);
                localStorage.setItem('clickedCriticalStates', JSON.stringify([...clickedCriticalStates]));
            }
            // Toggle class if element already exists
            const episode = episodes.find(e => e.id === ep);
            if (episode && episode.barEls && episode.barEls[st]) {
                episode.barEls[st].classList.add('clicked');
                episode.barEls[st].setAttribute('aria-pressed', 'true');
                // Remove title modification to eliminate hover text tooltip
            }
            
            // Update modal navigation if modal is open
            if (vlmModal.classList.contains('show')) {
                updateModalNavigation();
            }
        }

        // === NEW: hover preview popover for important bars ===
        let currentPopover = null;
        const previewCache = new Map(); // key => dataURL (or null)
        const previewInFlight = new Map(); // key => Promise

        function showPopover(x, y, tagText, imgUrl=null) {
            if (!currentPopover) {
                currentPopover = document.createElement('div');
                currentPopover.className = 'preview-popover';
                const badge = document.createElement('div');
                badge.className = 'badge';
                currentPopover.appendChild(badge);
                const inner = document.createElement('div');
                inner.className = 'loading';
                inner.textContent = 'Loading preview‚Ä¶';
                currentPopover.appendChild(inner);
                document.body.appendChild(currentPopover);
            }
            // Don't set badge text - only show obs view
            const inner = currentPopover.querySelector('.loading') || currentPopover.querySelector('img');
            if (imgUrl && imgUrl.startsWith('data:image/')) {
                if (inner && inner.tagName !== 'IMG') inner.remove();
                let img = currentPopover.querySelector('img');
                if (!img) {
                    img = document.createElement('img');
                    currentPopover.appendChild(img);
                }
                img.src = imgUrl;
            } else {
                // ensure loading placeholder
                let loading = currentPopover.querySelector('.loading');
                if (!loading) {
                    const existingImg = currentPopover.querySelector('img');
                    if (existingImg) existingImg.remove();
                    loading = document.createElement('div');
                    loading.className = 'loading';
                    currentPopover.appendChild(loading);
                }
                loading.textContent = imgUrl === null ? 'No preview' : 'Loading preview‚Ä¶';
            }
            positionPopover(x, y);
        }
        function positionPopover(x, y) {
            if (!currentPopover) return;
            const pad = 12;
            const rect = currentPopover.getBoundingClientRect();
            let left = x + 16;
            let top  = y + 16;
            const vw = window.innerWidth, vh = window.innerHeight;
            if (left + rect.width + pad > vw) left = vw - rect.width - pad;
            if (top + rect.height + pad > vh) top = vh - rect.height - pad;
            currentPopover.style.left = `${left}px`;
            currentPopover.style.top  = `${top}px`;
        }
        function hidePopover() {
            if (currentPopover) {
                currentPopover.remove();
                currentPopover = null;
            }
        }

        async function getMaincamPreview(ep, st) {
            const key = stateKey(ep, st);
            if (previewCache.has(key)) return previewCache.get(key);
            if (previewInFlight.has(key)) return previewInFlight.get(key);
            const p = (async () => {
                try {
                    const details = await fetchStateDetails(ep, st);
                    const url = details && details.maincam_data_url ? details.maincam_data_url : null;
                    previewCache.set(key, url);
                    return url;
                } catch {
                    previewCache.set(key, null);
                    return null;
                } finally {
                    previewInFlight.delete(key);
                }
            })();
            previewInFlight.set(key, p);
            return p;
        }

        // Bind click once for eligible bars
        function bindBarClickIfEligible(barContainer, episodeId, stateId, isCritical, hasVlmBoth) {
            barContainer.dataset.episodeId = String(episodeId);
            barContainer.dataset.stateId   = String(stateId);
            barContainer.classList.toggle('is-critical', !!isCritical);
            barContainer.classList.toggle('is-regular',   !isCritical);

            // NEW: critical states are always clickable (even if VLM is missing)
            if (isCritical) {
                barContainer.classList.add('clickable');
                if (barContainer.dataset.clickBound !== '1') {
                    barContainer.setAttribute('tabindex', '0'); // keyboard focus
                    const openFn = () => { markClickedCritical(episodeId, stateId); openVlmModal(episodeId, stateId); };
                    barContainer.addEventListener('click', openFn);
                    barContainer.addEventListener('keydown', (e) => { if (e.key === 'Enter') openFn(); });
                    barContainer.dataset.clickBound = '1';
                }
            } else {
                barContainer.classList.remove('clickable');
                barContainer.removeAttribute('tabindex');
            }

            // Hover preview (unchanged): only for critical bars
            if (isCritical && barContainer.dataset.hoverBound !== '1') {
                let hoverMoveHandler = null;
                let hoverEnterTimeout = null;
                barContainer.addEventListener('mouseenter', (e) => {
                    if (!criticalOnlyMode) return;
                    showPopover(e.clientX, e.clientY, null); // loading
                    hoverEnterTimeout = setTimeout(async () => {
                        const url = await getMaincamPreview(episodeId, stateId);
                        if (currentPopover) showPopover(e.clientX, e.clientY, null, url);
                    }, 140);
                    hoverMoveHandler = (ev) => positionPopover(ev.clientX, ev.clientY);
                    document.addEventListener('mousemove', hoverMoveHandler);
                });
                barContainer.addEventListener('mouseleave', () => {
                    if (hoverEnterTimeout) { clearTimeout(hoverEnterTimeout); hoverEnterTimeout = null; }
                    if (hoverMoveHandler) { document.removeEventListener('mousemove', hoverMoveHandler); hoverMoveHandler = null; }
                    hidePopover();
                });
                barContainer.dataset.hoverBound = '1';
            }
        }

        function updateEpisodeChart(episodeId, stateId, responsesReceived, isCritical, forceRefresh=false, hasVlmArtifacts /* bool */) {
            const episode = episodes.find(ep => ep.id === episodeId);
            if (!episode || !episode.barsContainer) return;

            if (forceRefresh) {
                const values = Object.values(episode.states || {});
                let totalResponses=0, critical=0, regular=0;
                for (const v of values) { totalResponses += v.responses||0; if (v.isCritical) critical++; else regular++; }
                episode.responsesTotal=totalResponses; episode.criticalCount=critical; episode.regularCount=regular;
                if (episode.statsElement) {
                    episode.statsElement.textContent = `${values.length} states (üî¥${critical} üîµ${regular}), ${totalResponses} responses`;
                }
                return;
            }
            if (!episode.states) episode.states = {};
            const prev = episode.states[stateId];
            if (!prev || prev.responses !== responsesReceived || prev.isCritical !== !!isCritical || prev.hasVlmArtifacts !== (!!hasVlmArtifacts)) {
                if (prev) {
                    episode.responsesTotal -= prev.responses||0;
                    if (prev.isCritical) episode.criticalCount--; else episode.regularCount--;
                }
                episode.responsesTotal += (responsesReceived||0);
                if (isCritical) episode.criticalCount++; else episode.regularCount++;
                episode.states[stateId] = { responses: responsesReceived||0, isCritical:!!isCritical, hasVlmArtifacts:!!hasVlmArtifacts };
            }

            let barContainer = episode.barEls[stateId];
            if (!barContainer) {
                barContainer = document.createElement('div');
                barContainer.className='state-bar-container';
                const bar = document.createElement('div'); bar.className='state-bar';
                barContainer.appendChild(bar);
                barContainer.dataset.stateId = String(stateId);
                const kids = episode.barsContainer.children;
                let inserted = false;
                for (let i=kids.length-1; i>=0; i--) {
                    const cur = parseInt(kids[i].dataset.stateId, 10);
                    if (cur <= stateId) { episode.barsContainer.insertBefore(barContainer, kids[i].nextSibling); inserted=true; break; }
                }
                if (!inserted) episode.barsContainer.insertBefore(barContainer, episode.barsContainer.firstChild);
                episode.barEls[stateId] = barContainer;
            }

            const bar = barContainer.firstChild;
            const required = isCritical ? REQUIRED_RESPONSES_PER_CRITICAL_STATE : REQUIRED_RESPONSES_PER_STATE;
            const hasVlm = (hasVlmArtifacts === undefined) ? true : !!hasVlmArtifacts;

            bar.className = 'state-bar';
            if ((responsesReceived||0) === 0) {
                bar.style.height = '100%';
                if (isCritical && !hasVlm) bar.classList.add('critical-awaiting-vlm');
                else bar.classList.add('empty');
            } else {
                const pct = Math.min((responsesReceived / Math.max(1, required)) * 100, 100);
                bar.style.height = `${pct}%`;
                if (isCritical && !hasVlm) bar.classList.add('critical-awaiting-vlm');
                else if (isCritical) bar.classList.add(responsesReceived >= required ? 'critical-complete' : 'critical-incomplete');
                else bar.classList.add(responsesReceived >= required ? 'regular-complete' : 'regular-incomplete');
            }

            const pct = Math.min((responsesReceived / Math.max(1, required)) * 100, 100);
            const vlmStr = isCritical ? (hasVlm ? 'VLM ‚úì (text+video)' : 'VLM missing') : 'Regular';
            const clicked = clickedCriticalStates.has(stateKey(episodeId, stateId)); /* NEW */
            // Remove title attribute to eliminate hover text tooltip

            // NEW: role, state classes, clicked marker
            barContainer.classList.toggle('is-critical', !!isCritical);
            barContainer.classList.toggle('is-regular', !isCritical);
            barContainer.classList.toggle('clicked', clicked);
            if (clicked) barContainer.setAttribute('aria-pressed','true'); else barContainer.removeAttribute('aria-pressed');

            // Bind click (if eligible) + hover
            bindBarClickIfEligible(barContainer, episodeId, stateId, !!isCritical, !!hasVlm);

            // Header stats
            if (episode.statsElement) {
                const count = Object.keys(episode.states).length;
                episode.statsElement.textContent = `${count} states (üî¥${episode.criticalCount} üîµ${episode.regularCount}), ${episode.responsesTotal} responses`;
            }
        }

        function updateCurrentEpisodeIndicator() {
            const current = episodes.find(ep => ep.isCurrentServing);
            document.querySelectorAll('.episode-chart').forEach(chart => chart.classList.remove('current'));
            if (current) {
                const el = document.getElementById(`episode-${current.id}`);
                if (el) {
                    el.classList.add('current');
                    if (!userIsScrolling) el.scrollIntoView({ behavior:'smooth', block:'nearest' });
                }
            }
        }

        function pruneMissingEpisodes(presentIds) {
            const present = new Set(presentIds);
            for (let i=episodes.length-1; i>=0; i--) {
                const ep = episodes[i];
                if (!present.has(ep.id)) {
                    const el = document.getElementById(`episode-${ep.id}`);
                    if (el) el.remove();
                    episodes.splice(i, 1);
                }
            }
            updateCurrentEpisodeIndicator();
        }

        function processMonitoringData(data) {
            if (data.required_responses_per_state) REQUIRED_RESPONSES_PER_STATE = data.required_responses_per_state;
            if (data.required_responses_per_critical_state) REQUIRED_RESPONSES_PER_CRITICAL_STATE = data.required_responses_per_critical_state;
            if (!data.episodes) return;

            pruneMissingEpisodes(Object.keys(data.episodes));

            for (const [episodeId, episodeData] of Object.entries(data.episodes)) {
                let episodeIndex = episodes.findIndex(ep => ep.id === episodeId);
                if (episodeIndex === -1) {
                    const newEpisode = {
                        index: episodes.length, id: episodeId, states: {}, maxStates: 0,
                        isComplete: episodeData.is_completed || false,
                        isCurrentServing: episodeData.is_current_serving || false
                    };
                    episodes.push(newEpisode);
                    createEpisodeChartElement(newEpisode);
                    episodeIndex = newEpisode.index;
                }
                const episode = episodes[episodeIndex];
                episode.isComplete = episodeData.is_completed || false;
                episode.isCurrentServing = episodeData.is_current_serving || false;

                if (episodeData.states) {
                    for (const [sidStr, info] of Object.entries(episodeData.states)) {
                        const sid = parseInt(sidStr, 10);
                        const isCritical = !!(info.critical || false);
                        const hasFlexBoth = Boolean(info.has_flex_text) && Boolean(info.has_flex_video);
                        updateEpisodeChart(episodeId, sid, info.responses_received || 0, isCritical, false, (isCritical ? hasFlexBoth : true));
                    }
                }

                const episodeElement = document.getElementById(`episode-${episodeId}`);
                if (episodeElement) {
                    const titleElement = episodeElement.querySelector('.episode-title');
                    if (titleElement) {
                        let title = `Episode ${episodeId}`;
                        if (episode.isCurrentServing) title += ' (Current)';
                        if (episode.isComplete) title += ' (Complete)';
                        titleElement.textContent = title;
                    }
                    episodeElement.classList.toggle('current', episode.isCurrentServing);
                    episodeElement.classList.toggle('complete', episode.isComplete);
                }
            }
            updateCurrentEpisodeIndicator();

            /* NEW: ensure filter is applied after updates */
            applyCriticalOnlyMode();
            
            /* Update modal navigation if modal is open */
            if (vlmModal.classList.contains('show')) {
                updateModalNavigation();
            }
        }

        // --- Fetchers ---
        async function fetchLatestState() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/monitor/latest-state`, { headers:{ 'Accept':'application/json' }});
                if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                const data = await response.json();
                updateServerStatus(true);
                if (data.status === 'success') {
                    if (data.views) for (const [name, url] of Object.entries(data.views)) updateCameraView(name, url);
                    updateRobotState(data.is_resetting, data.reset_countdown);
                    updateControlButtons(data.is_resetting);
                } else if (data.status === 'no_states' || data.status === 'no_pending_states') {
                    updateRobotState(data.is_resetting, data.reset_countdown);
                    updateControlButtons(data.is_resetting);
                    if (data.views) for (const [name, url] of Object.entries(data.views)) updateCameraView(name, url);
                }
            } catch (e) {
                console.error('Error fetching latest state:', e);
                updateServerStatus(false);
            }
        }

        async function fetchPendingStatesInfo() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/pending-states-info`, { headers:{ 'Accept':'application/json' }});
                if (response.ok) {
                    const data = await response.json();
                    processMonitoringData(data);
                }
            } catch (e) {
                console.error('Error fetching pending states info:', e);
            }
        }

        // --- Approval modal ---
        let currentApprovalState = null;

        async function fetchPendingApproval() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/control/pending-approval`, { headers:{ 'Accept':'application/json' }});
                if (!response.ok) return;
                
                const data = await response.json();
                
                if (data.status === 'pending') {
                    // New approval needed or state changed
                    if (!currentApprovalState || 
                        currentApprovalState.episode_id !== data.episode_id ||
                        currentApprovalState.state_id !== data.state_id) {
                        
                        currentApprovalState = data;
                        await showApprovalModal(data);
                    }
                } else {
                    // No pending approval
                    if (currentApprovalState) {
                        currentApprovalState = null;
                        hideApprovalModal();
                    }
                }
            } catch (e) {
                console.error('Error fetching pending approval:', e);
            }
        }

        async function showApprovalModal(data) {
            // Load images from data URLs
            if (data.current_image_url) {
                approvalNewImage.src = data.current_image_url;
            } else {
                approvalNewImage.src = '';
                approvalNewImage.alt = 'Image not available';
            }
            
            if (data.previous_image_url) {
                approvalPrevImage.src = data.previous_image_url;
                approvalPrevImage.style.opacity = '1';
            } else {
                approvalPrevImage.src = '';
                approvalPrevImage.style.opacity = '0.3';
                approvalPrevImage.alt = 'No previous critical state';
            }
            
            approvalModal.classList.add('show');
        }

        function hideApprovalModal() {
            approvalModal.classList.remove('show');
        }

        async function handleApprovalProceed() {
            if (!currentApprovalState) return;
            
            try {
                approvalProceedBtn.disabled = true;
                approvalRejectBtn.disabled = true;
                approvalDiscardBtn.disabled = true;
                approvalMarkEndBtn.disabled = true;
                
                const response = await fetch(`${API_BASE_URL}/api/control/approve-critical`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        episode_id: currentApprovalState.episode_id,
                        state_id: currentApprovalState.state_id
                    })
                });
                
                if (response.ok) {
                    showToast('‚úÖ Critical state approved');
                    currentApprovalState = null;
                    hideApprovalModal();
                } else {
                    showToast('‚ùå Failed to approve state', 2000);
                }
            } catch (e) {
                console.error('Error approving state:', e);
                showToast('‚ùå Error approving state', 2000);
            } finally {
                approvalProceedBtn.disabled = false;
                approvalRejectBtn.disabled = false;
                approvalDiscardBtn.disabled = false;
                approvalMarkEndBtn.disabled = false;
            }
        }

        async function handleApprovalReject() {
            if (!currentApprovalState) return;
            
            try {
                approvalProceedBtn.disabled = true;
                approvalRejectBtn.disabled = true;
                approvalDiscardBtn.disabled = true;
                approvalMarkEndBtn.disabled = true;
                
                const response = await fetch(`${API_BASE_URL}/api/control/reject-critical`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        episode_id: currentApprovalState.episode_id,
                        state_id: currentApprovalState.state_id
                    })
                });
                
                if (response.ok) {
                    showToast('‚ùå Critical state rejected, undoing...');
                    currentApprovalState = null;
                    hideApprovalModal();
                } else {
                    showToast('‚ùå Failed to reject state', 2000);
                }
            } catch (e) {
                console.error('Error rejecting state:', e);
                showToast('‚ùå Error rejecting state', 2000);
            } finally {
                approvalProceedBtn.disabled = false;
                approvalRejectBtn.disabled = false;
                approvalDiscardBtn.disabled = false;
                approvalMarkEndBtn.disabled = false;
            }
        }

        async function handleApprovalDiscard() {
            if (!currentApprovalState) return;
            
            try {
                approvalProceedBtn.disabled = true;
                approvalRejectBtn.disabled = true;
                approvalDiscardBtn.disabled = true;
                approvalMarkEndBtn.disabled = true;
                
                const response = await fetch(`${API_BASE_URL}/api/control/discard-jitter-states`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        episode_id: currentApprovalState.episode_id
                    })
                });
                
                if (response.ok) {
                    showToast('üóëÔ∏è Jitter states discarded');
                    // Clear the modal since we discarded the pending approval state too
                    currentApprovalState = null;
                    hideApprovalModal();
                } else {
                    showToast('‚ùå Failed to discard states', 2000);
                }
            } catch (e) {
                console.error('Error discarding states:', e);
                showToast('‚ùå Error discarding states', 2000);
            } finally {
                approvalProceedBtn.disabled = false;
                approvalRejectBtn.disabled = false;
                approvalDiscardBtn.disabled = false;
                approvalMarkEndBtn.disabled = false;
            }
        }

        async function handleApprovalMarkEnd() {
            if (!currentApprovalState) return;
            
            try {
                approvalProceedBtn.disabled = true;
                approvalRejectBtn.disabled = true;
                approvalDiscardBtn.disabled = true;
                approvalMarkEndBtn.disabled = true;
                
                const response = await fetch(`${API_BASE_URL}/api/control/mark-state-as-end`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        episode_id: currentApprovalState.episode_id,
                        state_id: currentApprovalState.state_id
                    })
                });
                
                if (response.ok) {
                    showToast('üèÅ State marked as end (episode will finish)');
                    currentApprovalState = null;
                    hideApprovalModal();
                } else {
                    showToast('‚ùå Failed to mark as end', 2000);
                }
            } catch (e) {
                console.error('Error marking as end:', e);
                showToast('‚ùå Error marking as end', 2000);
            } finally {
                approvalProceedBtn.disabled = false;
                approvalRejectBtn.disabled = false;
                approvalDiscardBtn.disabled = false;
                approvalMarkEndBtn.disabled = false;
            }
        }

        // Bind approval modal events
        approvalProceedBtn.addEventListener('click', handleApprovalProceed);
        approvalRejectBtn.addEventListener('click', handleApprovalReject);
        approvalDiscardBtn.addEventListener('click', handleApprovalDiscard);
        approvalMarkEndBtn.addEventListener('click', handleApprovalMarkEnd);

        // --- Pre-Execution Approval Modal ---
        let currentPreExecutionApproval = null;

        async function fetchPendingPreExecutionApproval() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/control/pending-pre-execution-approval`, { headers:{ 'Accept':'application/json' }});
                if (!response.ok) return;
                
                const data = await response.json();
                
                if (data.status === 'pending') {
                    // New pre-execution approval needed
                    // Check if it's a different approval (episode, state, OR action changed)
                    const actionChanged = !currentPreExecutionApproval || 
                        JSON.stringify(currentPreExecutionApproval.action) !== JSON.stringify(data.action);
                    
                    if (!currentPreExecutionApproval || 
                        currentPreExecutionApproval.episode_id !== data.episode_id ||
                        currentPreExecutionApproval.state_id !== data.state_id ||
                        actionChanged) {
                        
                        currentPreExecutionApproval = data;
                        await showPreExecutionModal(data);
                    }
                } else {
                    // No pending pre-execution approval
                    if (currentPreExecutionApproval) {
                        currentPreExecutionApproval = null;
                        hidePreExecutionModal();
                    }
                }
            } catch (e) {
                console.error('Error fetching pending pre-execution approval:', e);
            }
        }

        async function showPreExecutionModal(data) {
            // Load current observation image
            if (data.current_image_url) {
                preExecCurrentImage.src = data.current_image_url;
            } else {
                preExecCurrentImage.src = '';
                preExecCurrentImage.alt = 'Image not available';
            }
            
            // Clear previous views
            preExecViewsGrid.innerHTML = '';
            
            // Render views with robot overlay at proposed action joint positions
            const viewNames = ['front', 'left', 'right', 'top', 'webcam_front', 'webcam_left', 'webcam_right'];
            const viewLabels = {
                'front': 'Simulated: Front-view',
                'left': 'Simulated: Right-view',
                'right': 'Simulated: Left-view',
                'top': 'Simulated: Top-view',
                'webcam_front': 'Real-Life: Front-view',
                'webcam_left': 'Real-Life: Right-view',
                'webcam_right': 'Real-Life: Left-view'
            };
            
            for (const viewName of viewNames) {
                if (data.view_urls && data.view_urls[viewName]) {
                    const container = document.createElement('div');
                    container.className = 'pre-exec-view-container';
                    
                    const label = document.createElement('div');
                    label.className = 'pre-exec-view-label';
                    label.textContent = viewLabels[viewName] || viewName;
                    
                    const img = document.createElement('img');
                    img.className = 'pre-exec-view-canvas';
                    img.src = data.view_urls[viewName];
                    img.alt = viewName;
                    
                    container.appendChild(label);
                    container.appendChild(img);
                    preExecViewsGrid.appendChild(container);
                }
            }
            
            // Render robot at proposed action joint positions
            // data.action is already the joint positions array
            if (window.preExecRobotRenderer && data.action) {
                await window.preExecRobotRenderer.renderRobotAtAction(
                    data.action,
                    data.view_urls,
                    data.camera_poses,
                    data.camera_models,
                    viewNames
                );
            }
            
            preExecutionModal.classList.add('show');
            console.log('üéØ Pre-execution approval modal shown with action:', data.action);
        }

        function hidePreExecutionModal() {
            preExecutionModal.classList.remove('show');
        }

        async function handlePreExecutionApprove() {
            if (!currentPreExecutionApproval) return;
            
            try {
                preExecApproveBtn.disabled = true;
                preExecRejectBtn.disabled = true;
                
                const response = await fetch(`${API_BASE_URL}/api/control/approve-pre-execution`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        episode_id: currentPreExecutionApproval.episode_id,
                        state_id: currentPreExecutionApproval.state_id
                    })
                });
                
                if (response.ok) {
                    showToast('‚úÖ Action approved - executing...');
                    currentPreExecutionApproval = null;
                    hidePreExecutionModal();
                } else {
                    showToast('‚ùå Failed to approve action', 2000);
                }
            } catch (e) {
                console.error('Error approving pre-execution:', e);
                showToast('‚ùå Error approving action', 2000);
            } finally {
                preExecApproveBtn.disabled = false;
                preExecRejectBtn.disabled = false;
            }
        }

        async function handlePreExecutionReject() {
            if (!currentPreExecutionApproval) return;
            
            try {
                preExecApproveBtn.disabled = true;
                preExecRejectBtn.disabled = true;
                
                const response = await fetch(`${API_BASE_URL}/api/control/reject-pre-execution`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        episode_id: currentPreExecutionApproval.episode_id,
                        state_id: currentPreExecutionApproval.state_id
                    })
                });
                
                if (response.ok) {
                    showToast('‚ùå Action rejected - resampling...');
                    currentPreExecutionApproval = null;
                    hidePreExecutionModal();
                } else {
                    showToast('‚ùå Failed to reject action', 2000);
                }
            } catch (e) {
                console.error('Error rejecting pre-execution:', e);
                showToast('‚ùå Error rejecting action', 2000);
            } finally {
                preExecApproveBtn.disabled = false;
                preExecRejectBtn.disabled = false;
            }
        }

        // Bind pre-execution approval events
        preExecApproveBtn.addEventListener('click', handlePreExecutionApprove);
        preExecRejectBtn.addEventListener('click', handlePreExecutionReject);

        // --- Undo Classification Modal ---
        let currentUndoClassification = null;

        async function fetchPendingUndoClassification() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/control/pending-undo-classification`, { headers:{ 'Accept':'application/json' }});
                if (!response.ok) return;
                
                const data = await response.json();
                
                if (data.status === 'pending') {
                    // New classification needed or state changed
                    if (!currentUndoClassification || 
                        currentUndoClassification.episode_id !== data.episode_id ||
                        currentUndoClassification.state_id !== data.state_id) {
                        
                        currentUndoClassification = data;
                        await showUndoClassificationModal(data);
                    }
                } else {
                    // No pending classification
                    if (currentUndoClassification) {
                        currentUndoClassification = null;
                        hideUndoClassificationModal();
                    }
                }
            } catch (e) {
                console.error('Error fetching pending undo classification:', e);
            }
        }

        async function showUndoClassificationModal(data) {
            // Load previous state image (target)
            if (data.previous_image_url) {
                undoPreviousImage.src = data.previous_image_url;
            } else {
                undoPreviousImage.src = '';
                undoPreviousImage.alt = 'Image not available';
            }
            
            // Load arrived state image (after undo motion)
            if (data.arrived_image_url) {
                undoArrivedImage.src = data.arrived_image_url;
            } else {
                undoArrivedImage.src = '';
                undoArrivedImage.alt = 'Image not available';
            }
            
            // Show remaining actions info
            const numRemaining = data.num_remaining_actions || 0;
            if (numRemaining > 0) {
                undoRemainingActions.textContent = `${numRemaining} action(s) already executed, resampling available`;
                undoRemainingActions.style.color = '#28a745';
            } else {
                undoRemainingActions.textContent = 'No actions executed yet (both options available)';
                undoRemainingActions.style.color = '#555';
            }
            
            undoClassificationModal.classList.add('show');
        }

        function hideUndoClassificationModal() {
            undoClassificationModal.classList.remove('show');
            undoOldStateBtn.disabled = false;
        }

        async function handleUndoClassifyNewState() {
            if (!currentUndoClassification) return;
            
            try {
                undoNewStateBtn.disabled = true;
                undoOldStateBtn.disabled = true;
                undoMarkEndBtn.disabled = true;
                
                const response = await fetch(`${API_BASE_URL}/api/control/classify-undo-new-state`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        episode_id: currentUndoClassification.episode_id,
                        state_id: currentUndoClassification.state_id
                    })
                });
                
                if (response.ok) {
                    showToast('üÜï Classified as NEW STATE - will collect new actions');
                    currentUndoClassification = null;
                    hideUndoClassificationModal();
                } else {
                    showToast('‚ùå Failed to classify state', 2000);
                }
            } catch (e) {
                console.error('Error classifying as new state:', e);
                showToast('‚ùå Error classifying state', 2000);
            } finally {
                undoNewStateBtn.disabled = false;
                undoOldStateBtn.disabled = false;
                undoMarkEndBtn.disabled = false;
            }
        }

        async function handleUndoClassifyOldState() {
            if (!currentUndoClassification) return;
            
            try {
                undoNewStateBtn.disabled = true;
                undoOldStateBtn.disabled = true;
                undoMarkEndBtn.disabled = true;
                
                const response = await fetch(`${API_BASE_URL}/api/control/classify-undo-old-state`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        episode_id: currentUndoClassification.episode_id,
                        state_id: currentUndoClassification.state_id
                    })
                });
                
                if (response.ok) {
                    showToast('‚ôªÔ∏è Classified as OLD STATE - resampling actions');
                    currentUndoClassification = null;
                    hideUndoClassificationModal();
                } else {
                    showToast('‚ùå Failed to classify state', 2000);
                }
            } catch (e) {
                console.error('Error classifying as old state:', e);
                showToast('‚ùå Error classifying state', 2000);
            } finally {
                undoNewStateBtn.disabled = false;
                undoOldStateBtn.disabled = false;
                undoMarkEndBtn.disabled = false;
            }
        }

        async function handleUndoMarkEnd() {
            if (!currentUndoClassification) return;
            
            try {
                undoNewStateBtn.disabled = true;
                undoOldStateBtn.disabled = true;
                undoMarkEndBtn.disabled = true;
                
                const response = await fetch(`${API_BASE_URL}/api/control/mark-state-as-end`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        episode_id: currentUndoClassification.episode_id,
                        state_id: currentUndoClassification.state_id
                    })
                });
                
                if (response.ok) {
                    showToast('üèÅ State marked as end (episode will finish)');
                    currentUndoClassification = null;
                    hideUndoClassificationModal();
                } else {
                    showToast('‚ùå Failed to mark as end', 2000);
                }
            } catch (e) {
                console.error('Error marking as end:', e);
                showToast('‚ùå Error marking as end', 2000);
            } finally {
                undoNewStateBtn.disabled = false;
                undoOldStateBtn.disabled = false;
                undoMarkEndBtn.disabled = false;
            }
        }

        // Bind undo classification modal events
        undoNewStateBtn.addEventListener('click', handleUndoClassifyNewState);
        undoOldStateBtn.addEventListener('click', handleUndoClassifyOldState);
        undoMarkEndBtn.addEventListener('click', handleUndoMarkEnd);

        // --- Description bank helpers ---
        function extractThusText(s) {
            if (!s) return '';
            const idx = s.toLowerCase().indexOf('thus:');
            if (idx >= 0) return s.slice(idx + 5).trim().replace(/^[\s-:,]+/, '');
            return s.trim();
        }
        function parseDescriptionBank(raw) {
            // Raw can be a string (one numbered item per line) or an array of {id,text}
            if (Array.isArray(raw)) {
                return raw
                    .filter(x => typeof x === 'object' && x && typeof x.id !== 'undefined')
                    .map(x => ({ id: Number(x.id), text: String(x.text || ''), thus_text: extractThusText(String(x.text||'')) }))
                    .sort((a,b) => a.id - b.id);
            }
            if (typeof raw !== 'string') return [];
            const out = [];
            const lines = raw.split('\n');
            for (const line of lines) {
                const m = line.match(/^\s*(\d+)\.\s*(.+)$/);
                if (!m) continue;
                const id = Number(m[1]);
                const text = m[2].trim();
                out.push({ id, text, thus_text: extractThusText(text) });
            }
            out.sort((a,b) => a.id - b.id);
            return out;
        }

        async function fetchDescriptionBank() {
            try {
                const resp = await fetch(`${API_BASE_URL}/api/description-bank`, { headers:{ 'Accept':'application/json' }});
                if (!resp.ok) return null;
                const data = await resp.json();
                if (data && data.ok === true) {
                    return parseDescriptionBank(data.entries || data.raw_text || []);
                }
                return null;
            } catch {
                return null;
            }
        }

        // --- Modal logic ---
        function openModal()  { vlmModal.classList.add('show'); document.body.classList.add('modal-open'); }
        function closeModal() { vlmModal.classList.remove('show'); document.body.classList.remove('modal-open'); }

        function populateDropdown(items, selectedId) {
            modalSelect.innerHTML = '';
            for (const it of items) {
                const opt = document.createElement('option');
                opt.value = String(it.id);
                opt.textContent = `${it.id} - ${it.thus_text}`;
                if (it.id === selectedId) opt.selected = true;
                modalSelect.appendChild(opt);
            }
        }

        async function fetchStateDetails(episodeId, stateId) {
            const url = new URL(`${API_BASE_URL}/api/state-details`, location.origin);
            url.searchParams.set('episode_id', episodeId);
            url.searchParams.set('state_id', stateId);
            const resp = await fetch(url.toString().replace(location.origin,''), { headers:{ 'Accept':'application/json' }});
            if (!resp.ok) throw new Error(`Failed to fetch state details (${resp.status})`);
            const data = await resp.json();
            if (!data || data.ok !== true) throw new Error(data && data.error ? data.error : 'Bad response');
            return data;
        }

        async function openVlmModal(episodeId, stateId) {
            try {
                // Prime modal
                modalMaincam.src = '';
                modalPrompt.textContent = '‚Ä¶';
                kvEp.textContent = episodeId;
                kvSt.textContent = stateId;
                kvVid.textContent = '-';
                modalContext = { episodeId, stateId, selectedVideoId:null, selectedText:null, bank:[] };
                openModal();

                // Load details (maincam + current VLM + bank)
                const details = await fetchStateDetails(episodeId, stateId);

                if (details.maincam_data_url) {
                    modalMaincam.src = details.maincam_data_url;
                }

                const currentText = details.text_prompt || '';
                const currentVid  = (typeof details.video_prompt === 'number') ? details.video_prompt : null;

                // Show "NOT SET" if both text and video ID are not ready
                const isFlexReady = currentText.trim() && (currentVid !== null);
                modalPrompt.textContent = isFlexReady ? currentText : 'NOT SET';
                kvVid.textContent = (currentVid !== null ? String(currentVid) : '-');

                let bank = [];
                if (details.description_bank) {
                    bank = details.description_bank.map(entry => ({
                        id: entry.id,
                        thus_text: entry.text
                    }));
                } else {
                    const fallback = await fetchDescriptionBank();
                    bank = fallback || [];
                }
                modalContext.bank = bank;

                // Populate dropdown (pre-select current video id if present)
                populateDropdown(bank, currentVid ?? undefined);
                modalContext.selectedVideoId = currentVid;
                modalContext.selectedText = currentText;

                // NEW: Prefill manual fields & choose default source mode
                manualTextEl.value  = currentText || '';
                manualVideoEl.value = (currentVid !== null && currentVid !== undefined) ? String(currentVid) : '';

                // Always default to "Pick from bank" mode
                setSourceMode(false); // false = bank mode, true = manual mode

                // Keep modalContext aligned with current view
                modalContext.selectedVideoId = currentVid ?? (bank[0]?.id ?? null);
                modalContext.selectedText    = currentText || (bank[0]?.thus_text ?? null);

                // Only show first bank entry if flex is actually ready, otherwise keep "NOT SET"
                if (!isFlexReady && currentVid === null && bank.length) {
                    // Don't override the "NOT SET" text - keep it as is
                    kvVid.textContent = '-';
                }

                // Update navigation display
                updateModalNavigation();
            } catch (e) {
                console.error('Error in openVlmModal:', e);
                showToast('Failed to load VLM details.');
                closeModal();
            }
        }

        // Dropdown -> preview new text & video id (no save yet)
        modalSelect.addEventListener('change', () => {
            const selId = Number(modalSelect.value);
            const it = modalContext.bank.find(x => x.id === selId);
            if (it) {
                modalContext.selectedVideoId = it.id;
                modalContext.selectedText = it.thus_text;
                modalPrompt.textContent = it.thus_text;
                kvVid.textContent = String(it.id);
            }
        });

        // Save selection to backend
        async function saveVlmSelection() {
            const { episodeId, stateId } = modalContext;

            let payload = { episode_id: episodeId, state_id: stateId };
            if (isManualMode) {
                const txt = (manualTextEl.value || '').trim();
                if (!txt) { showToast('Enter manual text.'); return; }

                let vid = null;
                const raw = (manualVideoEl.value || '').trim();
                if (raw !== '') {
                    const num = Number(raw);
                    if (!Number.isFinite(num)) { showToast('Video ID must be a number.'); return; }
                    vid = num;
                }
                payload.text_prompt = txt;
                payload.video_prompt = vid;             // may be null
                payload.manual_override = true;          // NEW: tells backend to lock this state
                payload.source = 'manual';               // optional: for auditing
            } else {
                const txt = modalContext.selectedText;
                const vid = modalContext.selectedVideoId;
                if (!txt) { showToast('Pick a description first.'); return; }
                payload.text_prompt = txt;
                payload.video_prompt = vid;
                payload.manual_override = false;
                payload.source = 'bank';
            }

            try {
                const resp = await fetch(`${API_BASE_URL}/api/update-flex-selection`, {
                    method:'POST',
                    headers:{ 'Content-Type':'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await resp.json();
                if (!resp.ok || !data || data.ok !== true) throw new Error(data && data.error ? data.error : 'Save failed');

                markClickedCritical(episodeId, stateId);
                
                // Update the current text prompt in the modal
                const savedText = isManualMode ? (manualTextEl.value || '').trim() : modalContext.selectedText;
                if (savedText) {
                    modalPrompt.textContent = savedText;
                }
                
                // Update video ID display
                const savedVid = isManualMode ? 
                    ((manualVideoEl.value || '').trim() !== '' ? Number(manualVideoEl.value) : null) :
                    modalContext.selectedVideoId;
                kvVid.textContent = (savedVid !== null ? String(savedVid) : '-');
                
                showToast(isManualMode ? 'Saved (manual override locked).' : 'Updated VLM selection.');
                // Don't close modal - keep it open for further editing
                fetchPendingStatesInfo(); // refresh so bars/tooltips reflect new status
            } catch (e) {
                console.error(e);
                showToast('Failed to save selection.');
            }
        }

        // Modal buttons & close mechanisms
        vlmModalClose.addEventListener('click', closeModal);
        vlmModalCancel.addEventListener('click', closeModal);
        vlmModalSave.addEventListener('click', saveVlmSelection);
        vlmModal.addEventListener('click', (e) => { if (e.target === vlmModal) closeModal(); });
        document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && vlmModal.classList.contains('show')) closeModal(); });
        
        // Navigation between critical states with arrow keys
        function getAllCriticalStates() {
            const states = [];
            for (const episode of episodes) {
                for (const [stateId, stateInfo] of Object.entries(episode.states || {})) {
                    if (stateInfo.isCritical) {
                        states.push({
                            episodeId: episode.id,
                            stateId: parseInt(stateId, 10),
                            hasVlmArtifacts: stateInfo.hasVlmArtifacts,
                            sortKey: `${episode.id.padStart(6, '0')}_${stateId.padStart(6, '0')}`
                        });
                    }
                }
            }
            return states.sort((a, b) => a.sortKey.localeCompare(b.sortKey));
        }

        function updateModalNavigation() {
            const allCritical = getAllCriticalStates();
            const currentIndex = allCritical.findIndex(s => 
                s.episodeId === modalContext.episodeId && s.stateId === modalContext.stateId
            );

            // Update squares
            modalNavSquares.innerHTML = '';
            allCritical.forEach((state, index) => {
                const square = document.createElement('div');
                square.className = 'modal-nav-square';
                
                const isVisited = clickedCriticalStates.has(stateKey(state.episodeId, state.stateId));
                const isCurrent = index === currentIndex;
                
                // Start with default gray appearance, no flashing
                if (isVisited) square.classList.add('visited');
                if (isCurrent) square.classList.add('current');
                
                square.title = `Episode ${state.episodeId}, State ${state.stateId}`;
                square.addEventListener('click', () => {
                    openVlmModal(state.episodeId, state.stateId);
                });
                
                // Check label status asynchronously without initial visual indication
                checkStateLabelStatus(state.episodeId, state.stateId, square, isVisited);
                
                modalNavSquares.appendChild(square);
            });

            // Update info text
            navCurrentIndex.textContent = currentIndex + 1;
            navTotalCount.textContent = allCritical.length;
        }

        async function checkStateLabelStatus(episodeId, stateId, square, isVisited) {
            try {
                const details = await fetchStateDetails(episodeId, stateId);
                const hasText = details.text_prompt && details.text_prompt.trim();
                const hasVideoId = details.video_prompt !== null && details.video_prompt !== undefined;
                const isLabeled = hasText && hasVideoId;
                
                // Add unlabeled styling if not labeled (regardless of visited status)
                // Visited states keep their green color, but unlabeled ones show red
                if (!isLabeled) {
                    square.classList.add('unlabeled');
                    square.title += ' (Unlabeled)';
                }
            } catch (e) {
                // If we can't fetch details, assume unlabeled
                square.classList.add('unlabeled');
                square.title += ' (Unlabeled)';
            }
        }

        function navigateToAdjacentCriticalState(direction) {
            if (!vlmModal.classList.contains('show') || !modalContext.episodeId || !modalContext.stateId) return;
            
            const allCritical = getAllCriticalStates();
            if (allCritical.length <= 1) return;
            
            const currentIndex = allCritical.findIndex(s => 
                s.episodeId === modalContext.episodeId && s.stateId === modalContext.stateId
            );
            
            if (currentIndex === -1) return;
            
            let nextIndex;
            if (direction === 'next') {
                nextIndex = (currentIndex + 1) % allCritical.length;
            } else {
                nextIndex = (currentIndex - 1 + allCritical.length) % allCritical.length;
            }
            
            const nextState = allCritical[nextIndex];
            openVlmModal(nextState.episodeId, nextState.stateId);
        }

        // Quick save with Ctrl+Enter / ‚åò+Enter while modal is open
        // Arrow key navigation between critical states
        document.addEventListener('keydown', (e) => {
            if (!vlmModal.classList.contains('show')) return;
            
            // Navigation with arrow keys
            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                navigateToAdjacentCriticalState('prev');
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                navigateToAdjacentCriticalState('next');
            }
            
            // Quick save
            const meta = e.ctrlKey || e.metaKey;
            if (meta && e.key === 'Enter') {
                e.preventDefault();
                saveVlmSelection();
            }
        });

        // --- Controls ---
        async function handleFastForward() {
            const buttonText = fastForwardBtn.textContent;
            const isStartEpisode = buttonText.includes('Start Episode');
            const button = fastForwardBtn; button.classList.add('loading'); button.disabled = true;
            try {
                const endpoint = isStartEpisode ? '/api/control/start-episode' : '/api/control/next-episode';
                const response = await fetch(`${API_BASE_URL}${endpoint}`, { method:'POST', headers:{ 'Content-Type':'application/json' }});
                const result = await response.json();
                if (result.status === 'success') {
                    // noop: next fetch will update UI
                } else {
                    console.error('Failed:', result.message);
                }
            } catch (e) {
                console.error(e);
            } finally { button.classList.remove('loading'); button.disabled = false; }
        }
        async function handleRerecord() {
            const b = rerecordBtn; b.classList.add('loading'); b.disabled = true;
            try {
                const r = await fetch(`${API_BASE_URL}/api/control/rerecord`, { method:'POST', headers:{ 'Content-Type':'application/json' }});
                const j = await r.json();
                if (j.status !== 'success') console.error('Failed:', j.message);
            } catch (e) { console.error(e); }
            finally { b.classList.remove('loading'); b.disabled = false; }
        }
        async function handleStop() {
            const b = stopBtn; b.classList.add('loading'); b.disabled = true;
            try {
                const r = await fetch(`${API_BASE_URL}/api/control/stop`, { method:'POST', headers:{ 'Content-Type':'application/json' }});
                const j = await r.json();
                if (j.status !== 'success') console.error('Failed:', j.message);
            } catch (e) { console.error(e); }
            finally { b.classList.remove('loading'); b.disabled = false; }
        }
        fastForwardBtn.addEventListener('click', handleFastForward);
        rerecordBtn.addEventListener('click', handleRerecord);
        stopBtn.addEventListener('click', handleStop);

        // === NEW: Critical-only toggle logic ===
        let criticalOnlyMode = true; // Default to Critical only
        const toggleAllBtn = document.getElementById('toggle-all');
        const toggleCriticalBtn = document.getElementById('toggle-critical');

        function updateToggleUI() {
            if (criticalOnlyMode) {
                toggleAllBtn.classList.remove('active');
                toggleAllBtn.setAttribute('aria-selected','false');
                toggleCriticalBtn.classList.add('active');
                toggleCriticalBtn.setAttribute('aria-selected','true');
            } else {
                toggleCriticalBtn.classList.remove('active');
                toggleCriticalBtn.setAttribute('aria-selected','false');
                toggleAllBtn.classList.add('active');
                toggleAllBtn.setAttribute('aria-selected','true');
            }
        }

        function applyCriticalOnlyMode() {
            for (const ep of episodes) {
                if (!ep.barsContainer) continue;
                ep.barsContainer.classList.toggle('critical-only', criticalOnlyMode);
            }
        }

        toggleAllBtn.addEventListener('click', () => {
            criticalOnlyMode = false;
            updateToggleUI();
            applyCriticalOnlyMode();
            hidePopover();
        });
        toggleCriticalBtn.addEventListener('click', () => {
            criticalOnlyMode = true;
            updateToggleUI();
            applyCriticalOnlyMode();
        });
        // Keyboard shortcut: I toggles mode
        document.addEventListener('keydown', (e) => {
            if (e.key.toLowerCase() === 'i' && !document.body.classList.contains('modal-open')) {
                criticalOnlyMode = !criticalOnlyMode;
                updateToggleUI();
                applyCriticalOnlyMode();
                if (!criticalOnlyMode) hidePopover();
            }
        });

        // --- Auto-refresh ---
        function startAutoRefresh() {
            stopAutoRefresh();
            autoRefreshInterval = {
                cameras: setInterval(() => {
                    if (!latestStateInFlight) {
                        latestStateInFlight = true; fetchLatestState().finally(()=>latestStateInFlight=false);
                    }
                }, CAMERA_POLL_MS),
                info: setInterval(() => {
                    if (!pendingInfoInFlight) {
                        pendingInfoInFlight = true; fetchPendingStatesInfo().finally(()=>pendingInfoInFlight=false);
                    }
                }, INFO_POLL_MS),
                preExecutionApproval: setInterval(() => {
                    fetchPendingPreExecutionApproval();
                }, 500),  // Poll pre-execution approval more frequently (500ms)
                approval: setInterval(() => {
                    fetchPendingApproval();
                }, 500),  // Poll approval more frequently (500ms)
                undoClassification: setInterval(() => {
                    fetchPendingUndoClassification();
                }, 500)  // Poll undo classification at same rate
            };
        }
        function stopAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval.cameras);
                clearInterval(autoRefreshInterval.info);
                clearInterval(autoRefreshInterval.preExecutionApproval);
                clearInterval(autoRefreshInterval.approval);
                clearInterval(autoRefreshInterval.undoClassification);
                autoRefreshInterval = null;
            }
        }

        // Init
        document.addEventListener('DOMContentLoaded', async () => {
            await initializeApiUrl();
            episodeChartsContainer.addEventListener('scroll', () => {
                userIsScrolling = true; if (scrollTimeout) clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(()=>userIsScrolling=false, 3000);
            });
            await fetchPendingStatesInfo();
            fetchLatestState();
            startAutoRefresh();
            setTimeout(fetchPendingStatesInfo, 500);

            // Initialize toggle UI state
            updateToggleUI();
            applyCriticalOnlyMode();
        });
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) stopAutoRefresh();
            else startAutoRefresh();
        });
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import URDFLoader from 'urdf-loader';
        
        class PreExecutionRobotRenderer {
            constructor() {
                this.robot = null;
                this.loading = false;
                this.loaded = false;
                this.scenes = new Map();
                this.renderers = new Map();
                this.ROBOT_Z_OFFSET = 0.005;
            }
            
            async loadRobot() {
                if (this.loaded) return this.robot;
                if (this.loading) {
                    // Wait for existing load
                    return new Promise((resolve) => {
                        const check = setInterval(() => {
                            if (this.loaded) {
                                clearInterval(check);
                                resolve(this.robot);
                            }
                        }, 100);
                    });
                }
                
                this.loading = true;
                
                return new Promise((resolve, reject) => {
                    const loader = new URDFLoader();
                    loader.packages = {
                        'trossen_arm_description': '/assets/trossen_arm_description'
                    };
                    
                    loader.load(
                        '/assets/trossen_arm_description/urdf/generated/wxai/wxai_base.urdf',
                        (robot) => {
                            this.robot = robot;
                            this.applyGoldTint(robot);
                            this.loaded = true;
                            this.loading = false;
                            resolve(robot);
                        },
                        undefined,
                        (error) => {
                            console.error('Failed to load URDF:', error);
                            this.loading = false;
                            reject(error);
                        }
                    );
                });
            }
            
            applyGoldTint(root) {
                const GOLD_HEX = 0xffc83d;
                const GOLD_EMISSIVE_HEX = 0x6a4b00;
                
                root.traverse(obj => {
                    if (obj.isMesh && obj.material) {
                        const materials = Array.isArray(obj.material) ? obj.material : [obj.material];
                        materials.forEach(mat => {
                            if (mat.color) mat.color.setHex(GOLD_HEX);
                            if (mat.emissive) {
                                mat.emissive.setHex(GOLD_EMISSIVE_HEX);
                                mat.emissiveIntensity = 0.40;
                            }
                            if ('metalness' in mat) mat.metalness = 0.6;
                            if ('roughness' in mat) mat.roughness = 0.35;
                            mat.needsUpdate = true;
                        });
                    }
                });
            }
            
            poseToMatrix(mat) {
                return new THREE.Matrix4().set(
                    mat[0][0], mat[0][1], mat[0][2], mat[0][3],
                    mat[1][0], mat[1][1], mat[1][2], mat[1][3],
                    mat[2][0], mat[2][1], mat[2][2], mat[2][3],
                    mat[3][0], mat[3][1], mat[3][2], mat[3][3]
                );
            }
            
            createCamera(viewName, cameraModel, cameraPose, canvasWidth, canvasHeight) {
                // Check if orthographic (simulated views)
                const isOrthographic = cameraModel && cameraModel.projection_type === 'orthographic';
                
                const camera = isOrthographic 
                    ? new THREE.OrthographicCamera(-1, 1, 1, -1, 0.01, 100)
                    : new THREE.PerspectiveCamera(45, 1, 0.01, 100);
                
                // Apply camera pose (extrinsics) - pose is a 4x4 matrix
                if (cameraPose && Array.isArray(cameraPose)) {
                    const m = this.poseToMatrix(cameraPose);
                    const pos = new THREE.Vector3();
                    const quat = new THREE.Quaternion();
                    const scale = new THREE.Vector3();
                    m.decompose(pos, quat, scale);
                    
                    camera.position.copy(pos);
                    camera.quaternion.copy(quat);
                    camera.updateMatrixWorld();
                }
                
                // Apply camera intrinsics using projection matrix (like sim.html does)
                if (cameraModel && cameraModel.Knew) {
                    const K = cameraModel.Knew;
                    const W = cameraModel.width || 640;
                    const H = cameraModel.height || 480;
                    const near = camera.near;
                    const far = camera.far;
                    
                    // Scale intrinsics to canvas size
                    const vw = canvasWidth;
                    const vh = canvasHeight;
                    const sx = vw / W;
                    const sy = vh / H;
                    
                    if (isOrthographic) {
                        // Orthographic projection
                        const orthoWidth = cameraModel.orthographic_width || 1.0;
                        const orthoHeight = cameraModel.orthographic_height || 1.0;
                        
                        const left = -orthoWidth / 2;
                        const right = orthoWidth / 2;
                        const top = orthoHeight / 2;
                        const bottom = -orthoHeight / 2;
                        
                        const P = new THREE.Matrix4().makeOrthographic(left, right, top, bottom, near, far);
                        camera.projectionMatrix.copy(P);
                        camera.projectionMatrixInverse.copy(P).invert();
                        camera.projectionMatrixAutoUpdate = false;
                    } else {
                        // Perspective projection
                        const fx = K[0][0] * sx;
                        const fy = K[1][1] * sy;
                        const cx = K[0][2] * sx;
                        const cy = K[1][2] * sy;
                        
                        // OpenCV pixels (origin top-left, +y down) ‚Üí Three frustum (y up)
                        const left   = -cx * near / fx;
                        const right  =  (vw - cx) * near / fx;
                        const top    =  cy * near / fy;
                        const bottom = -(vh - cy) * near / fy;
                        
                        const P = new THREE.Matrix4().makePerspective(left, right, top, bottom, near, far);
                        camera.projectionMatrix.copy(P);
                        camera.projectionMatrixInverse.copy(P).invert();
                        camera.projectionMatrixAutoUpdate = false;
                    }
                }
                
                return camera;
            }
            
            setRobotJoints(robot, jointPositions) {
                // jointPositions is array: [joint_0, joint_1, joint_2, joint_3, joint_4, joint_5, left_carriage_joint]
                const jointNames = ['joint_0', 'joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'left_carriage_joint'];
                jointNames.forEach((name, i) => {
                    if (jointPositions[i] !== undefined) {
                        robot.setJointValue(name, jointPositions[i]);
                    }
                });
                robot.updateMatrixWorld(true);
            }
            
            async renderRobotAtAction(jointPositions, viewUrls, cameraPoses, cameraModels, viewNames) {
                try {
                    await this.loadRobot();
                    
                    // For each view, create a canvas overlay and render the robot
                    const containers = document.querySelectorAll('.pre-exec-view-container');
                    
                    for (const container of containers) {
                        const img = container.querySelector('img');
                        if (!img) continue;
                        
                        const viewName = img.alt;
                        if (!viewNames.includes(viewName)) continue;
                        
                        // Wait for image to load to get dimensions
                        await new Promise((resolve) => {
                            if (img.complete) resolve();
                            else img.onload = resolve;
                        });
                        
                        // Use image's natural dimensions for rendering
                        const renderWidth = img.naturalWidth || 640;
                        const renderHeight = img.naturalHeight || 480;
                        
                        // Create WebGL canvas for robot rendering
                        const webglCanvas = document.createElement('canvas');
                        webglCanvas.width = renderWidth;
                        webglCanvas.height = renderHeight;
                        
                        // Get camera for this view
                        const poseKey = `${viewName}_pose`;
                        const cameraPose = cameraPoses[poseKey];
                        const cameraModel = cameraModels[viewName];
                        
                        if (!cameraPose || !cameraModel) continue;
                        
                        // Create scene for this view
                        const scene = new THREE.Scene();
                        const camera = this.createCamera(viewName, cameraModel, cameraPose, webglCanvas.width, webglCanvas.height);
                        
                        // Clone robot for this view
                        const robotClone = this.robot.clone();
                        const robotGroup = new THREE.Group();
                        robotGroup.position.z = this.ROBOT_Z_OFFSET;
                        robotGroup.add(robotClone);
                        scene.add(robotGroup);
                        
                        // Set robot joints to proposed action positions
                        this.setRobotJoints(robotClone, jointPositions);
                        
                        // Make robot visible (show all meshes)
                        robotClone.traverse(obj => {
                            if (obj.isMesh) obj.visible = true;
                        });
                        
                        // Add lighting (matching sim.html)
                        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
                        scene.add(hemiLight);
                        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
                        dirLight.position.set(2, 4, 2);
                        scene.add(dirLight);
                        
                        // Create renderer
                        const renderer = new THREE.WebGLRenderer({ 
                            canvas: webglCanvas, 
                            alpha: true,
                            antialias: true,
                            preserveDrawingBuffer: true
                        });
                        renderer.setClearColor(0x000000, 0); // Transparent
                        renderer.setSize(webglCanvas.width, webglCanvas.height);
                        
                        // Render robot
                        renderer.render(scene, camera);
                        
                        // Create 2D canvas for compositing
                        const compositeCanvas = document.createElement('canvas');
                        compositeCanvas.width = renderWidth;
                        compositeCanvas.height = renderHeight;
                        const ctx = compositeCanvas.getContext('2d');
                        
                        // Draw background image first
                        ctx.drawImage(img, 0, 0, renderWidth, renderHeight);
                        
                        // Draw robot overlay on top
                        ctx.drawImage(webglCanvas, 0, 0);
                        
                        // Convert to data URL and replace image source
                        const compositeDataUrl = compositeCanvas.toDataURL('image/jpeg', 0.95);
                        img.src = compositeDataUrl;
                        
                        // Clean up
                        renderer.dispose();
                        this.scenes.set(viewName, scene);
                        this.renderers.set(viewName, renderer);
                    }
                } catch (error) {
                    console.error('Error rendering robot:', error);
                }
            }
            
            dispose() {
                for (const renderer of this.renderers.values()) {
                    renderer.dispose();
                }
                this.scenes.clear();
                this.renderers.clear();
            }
        }
        
        // Create global instance
        window.preExecRobotRenderer = new PreExecutionRobotRenderer();
        
        // Pre-load robot for faster first render
        window.preExecRobotRenderer.loadRobot().catch(err => {
            console.error('Failed to preload robot:', err);
        });
    </script>
</body>
</html>
